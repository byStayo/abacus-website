<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Fraud Finder</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 500px; margin: 0 auto; }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .back-link { color: #7d8590; text-decoration: none; font-size: 14px; }
        .back-link:hover { color: #58a6ff; }
        h1 { font-size: 24px; font-weight: 600; color: #e6edf3; }
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 16px;
        }
        .stat { text-align: center; }
        .stat-label { font-size: 11px; color: #7d8590; text-transform: uppercase; }
        .stat-value { font-size: 24px; font-weight: 700; color: #f85149; }
        .difficulty {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        .diff-btn {
            background-color: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        .diff-btn.active {
            background-color: #238636;
            border-color: #238636;
            color: white;
        }
        .board-wrapper {
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 12px;
            display: inline-block;
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }
        .board {
            display: grid;
            gap: 2px;
        }
        .cell {
            width: 32px;
            height: 32px;
            background-color: #21262d;
            border: 1px solid #30363d;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            user-select: none;
            transition: background-color 0.1s;
        }
        .cell:hover:not(.revealed):not(.flagged) { background-color: #30363d; }
        .cell.revealed { background-color: #161b22; cursor: default; }
        .cell.mine { background-color: #da3633; }
        .cell.mine.hit { background-color: #ff0000; animation: mineHit 0.3s ease; }
        @keyframes mineHit {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        .cell.flagged { background-color: #6e40c9; }
        .cell.flagged::after { content: 'ðŸš©'; }
        .cell.long-press { animation: longPressHint 0.3s ease; }
        @keyframes longPressHint {
            0% { transform: scale(1); }
            100% { transform: scale(0.95); background-color: #6e40c9; }
        }
        .cell[data-count="1"] { color: #58a6ff; }
        .cell[data-count="2"] { color: #3fb950; }
        .cell[data-count="3"] { color: #f85149; }
        .cell[data-count="4"] { color: #8957e5; }
        .cell[data-count="5"] { color: #da3633; }
        .cell[data-count="6"] { color: #39c5cf; }
        .cell[data-count="7"] { color: #e6edf3; }
        .cell[data-count="8"] { color: #7d8590; }
        .overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(13, 17, 23, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .overlay.active { display: flex; }
        .overlay-content { text-align: center; }
        .overlay-title { font-size: 36px; font-weight: 800; margin-bottom: 16px; }
        .overlay-title.win { color: #3fb950; }
        .overlay-title.lose { color: #f85149; }
        .overlay-stats { font-size: 16px; color: #7d8590; margin-bottom: 24px; }
        .play-btn {
            background-color: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 14px 32px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        .instructions {
            text-align: center;
            margin-top: 16px;
            font-size: 12px;
            color: #7d8590;
        }

        /* Confetti */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 1000;
            animation: confetti-fall 2.5s ease-out forwards;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg) scale(0.5); opacity: 0; }
        }

        /* Reveal animation */
        .cell.reveal-anim {
            animation: revealPop 0.2s ease-out;
        }
        @keyframes revealPop {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Flag animation */
        .cell.flag-anim {
            animation: flagPop 0.2s ease-out;
        }
        @keyframes flagPop {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        /* Screen shake */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px) translateY(4px); }
            75% { transform: translateX(8px) translateY(-4px); }
        }
        .shake { animation: shake 0.3s ease-in-out; }

        /* Win glow */
        .board-wrapper.won {
            box-shadow: 0 0 30px rgba(63, 185, 80, 0.5);
            animation: winGlow 1s ease-in-out infinite alternate;
        }
        @keyframes winGlow {
            from { box-shadow: 0 0 20px rgba(63, 185, 80, 0.3); }
            to { box-shadow: 0 0 40px rgba(63, 185, 80, 0.6); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div style="position:absolute;top:20px;left:20px;display:flex;align-items:center;gap:8px;font-size:14px;"><a href="/" style="color:#7d8590;text-decoration:none;">Abacus</a><span style="color:#7d8590;opacity:0.5;">/</span><a href="/" style="color:#7d8590;text-decoration:none;">Games</a><span style="color:#7d8590;opacity:0.5;">/</span><span style="color:#e6edf3;">Minesweeper</span></div>
            <h1>Fraud Finder</h1>
        </header>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Frauds</div>
                <div class="stat-value" id="mines">10</div>
            </div>
            <div class="stat">
                <div class="stat-label">Flagged</div>
                <div class="stat-value" id="flagged" style="color: #6e40c9;">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="time" style="color: #58a6ff;">0:00</div>
            </div>
        </div>
        <div class="difficulty">
            <button class="diff-btn active" data-size="9" data-mines="10">Easy</button>
            <button class="diff-btn" data-size="12" data-mines="20">Medium</button>
            <button class="diff-btn" data-size="16" data-mines="40">Hard</button>
        </div>
        <div class="board-wrapper">
            <div class="board" id="board"></div>
        </div>
        <p class="instructions">Click to reveal | Right-click or long-press to flag</p>
    </div>
    <div class="overlay" id="overlay">
        <div class="overlay-content">
            <div class="overlay-title" id="overlay-title">Game Over</div>
            <div class="overlay-stats" id="overlay-stats"></div>
            <button class="play-btn" id="restart-btn">Play Again</button>
        </div>
    </div>
    <script>
        let gridSize = 9;
        let mineCount = 10;
        let board = [];
        let revealed = [];
        let flagged = [];
        let gameOver = false;
        let firstClick = true;
        let startTime = null;
        let timerInterval = null;
        let hitMine = null; // Track which mine was clicked
        let longPressTimer = null;
        let longPressCell = null;
        let revealQueue = [];
        let revealIndex = 0;

        // Best times per difficulty
        let bestTimes = {
            9: parseInt(localStorage.getItem('fraudFinderBest9')) || 0,
            12: parseInt(localStorage.getItem('fraudFinderBest12')) || 0,
            16: parseInt(localStorage.getItem('fraudFinderBest16')) || 0
        };

        const boardEl = document.getElementById('board');
        const minesEl = document.getElementById('mines');
        const flaggedEl = document.getElementById('flagged');
        const timeEl = document.getElementById('time');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlay-title');
        const overlayStats = document.getElementById('overlay-stats');

        // Audio system
        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone(freq, duration = 0.1, type = 'sine', volume = 0.3) {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(volume, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        function playReveal(depth = 0) {
            const freq = 400 + depth * 50;
            playTone(freq, 0.05, 'square', 0.1);
        }

        function playFlag() {
            playTone(600, 0.08, 'triangle', 0.2);
            setTimeout(() => playTone(800, 0.08, 'triangle', 0.15), 50);
        }

        function playUnflag() {
            playTone(500, 0.06, 'triangle', 0.15);
        }

        function playMine() {
            playTone(150, 0.4, 'sawtooth', 0.3);
            setTimeout(() => playTone(100, 0.3, 'sawtooth', 0.2), 100);
            setTimeout(() => playTone(80, 0.4, 'sawtooth', 0.15), 200);
        }

        function playWin() {
            const notes = [523, 659, 784, 880, 1047, 1319];
            notes.forEach((freq, i) => {
                setTimeout(() => playTone(freq, 0.2, 'sine', 0.25), i * 100);
            });
        }

        function playClick() {
            playTone(300, 0.03, 'square', 0.1);
        }

        // Confetti
        function confetti(count = 60) {
            const colors = ['#3fb950', '#58a6ff', '#d29922', '#a371f7', '#ffd700'];
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'confetti';
                particle.style.left = (Math.random() * window.innerWidth) + 'px';
                particle.style.top = '-20px';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.animationDelay = (Math.random() * 0.5) + 's';
                particle.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 2500);
            }
        }

        // Screen shake
        function screenShake() {
            document.querySelector('.board-wrapper').classList.add('shake');
            setTimeout(() => document.querySelector('.board-wrapper').classList.remove('shake'), 300);
        }

        function createGame() {
            board = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
            revealed = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            flagged = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            gameOver = false;
            firstClick = true;
            hitMine = null;
            revealQueue = [];
            revealIndex = 0;

            if (timerInterval) clearInterval(timerInterval);
            startTime = null;
            timeEl.textContent = '0:00';
            minesEl.textContent = mineCount;
            flaggedEl.textContent = '0';

            document.querySelector('.board-wrapper').classList.remove('won');

            renderBoard();
        }

        function placeMines(excludeRow, excludeCol) {
            let placed = 0;
            while (placed < mineCount) {
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                if (board[row][col] !== -1 &&
                    !(Math.abs(row - excludeRow) <= 1 && Math.abs(col - excludeCol) <= 1)) {
                    board[row][col] = -1;
                    placed++;
                }
            }

            // Calculate numbers
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] === -1) continue;
                    let count = 0;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr, nc = c + dc;
                            if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize && board[nr][nc] === -1) {
                                count++;
                            }
                        }
                    }
                    board[r][c] = count;
                }
            }
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${gridSize}, 32px)`;

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    if (revealed[r][c]) {
                        cell.classList.add('revealed');
                        if (board[r][c] === -1) {
                            cell.classList.add('mine');
                            // Distinguish hit mine from other revealed mines
                            if (hitMine && hitMine.r === r && hitMine.c === c) {
                                cell.classList.add('hit');
                            }
                            cell.textContent = 'ðŸ’€';
                        } else if (board[r][c] > 0) {
                            cell.textContent = board[r][c];
                            cell.dataset.count = board[r][c];
                        }
                    } else if (flagged[r][c]) {
                        cell.classList.add('flagged');
                    }

                    cell.addEventListener('click', () => handleClick(r, c));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        handleRightClick(r, c);
                    });

                    // Long-press for mobile flagging
                    cell.addEventListener('touchstart', (e) => {
                        longPressCell = { r, c, el: cell };
                        longPressTimer = setTimeout(() => {
                            if (longPressCell) {
                                handleRightClick(r, c);
                                longPressCell = null;
                            }
                        }, 500);
                    });
                    cell.addEventListener('touchend', () => {
                        clearTimeout(longPressTimer);
                        longPressCell = null;
                    });
                    cell.addEventListener('touchmove', () => {
                        clearTimeout(longPressTimer);
                        longPressCell = null;
                    });

                    boardEl.appendChild(cell);
                }
            }
        }

        function handleClick(row, col) {
            if (gameOver || flagged[row][col] || revealed[row][col]) return;

            initAudio();
            playClick();

            if (firstClick) {
                firstClick = false;
                placeMines(row, col);
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
            }

            revealQueue = [];
            revealIndex = 0;
            reveal(row, col, 0);

            // Animate cascade reveals
            if (revealQueue.length > 1) {
                animateCascade();
            } else {
                renderBoard();
                checkWin();
            }
        }

        function animateCascade() {
            if (revealIndex >= revealQueue.length) {
                checkWin();
                return;
            }

            const batch = [];
            const baseDelay = 15;

            // Process a few cells at a time for smoother animation
            for (let i = 0; i < 3 && revealIndex < revealQueue.length; i++) {
                batch.push(revealQueue[revealIndex]);
                revealIndex++;
            }

            batch.forEach((item, i) => {
                setTimeout(() => {
                    const cell = boardEl.querySelector(`[data-row="${item.r}"][data-col="${item.c}"]`);
                    if (cell) {
                        cell.classList.add('revealed', 'reveal-anim');
                        cell.classList.remove('flagged');
                        if (board[item.r][item.c] > 0) {
                            cell.textContent = board[item.r][item.c];
                            cell.dataset.count = board[item.r][item.c];
                        }
                        playReveal(item.depth);
                    }
                }, i * baseDelay);
            });

            setTimeout(animateCascade, batch.length * baseDelay);
        }

        function handleRightClick(row, col) {
            if (gameOver || revealed[row][col]) return;

            initAudio();
            const wasFlagged = flagged[row][col];
            flagged[row][col] = !wasFlagged;

            if (wasFlagged) {
                playUnflag();
            } else {
                playFlag();
            }

            const flagCount = flagged.flat().filter(f => f).length;
            flaggedEl.textContent = flagCount;

            // Add animation to the cell
            const cell = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cell && !wasFlagged) {
                cell.classList.add('flagged', 'flag-anim');
                setTimeout(() => cell.classList.remove('flag-anim'), 200);
            } else if (cell) {
                cell.classList.remove('flagged');
            }

            renderBoard();
        }

        function reveal(row, col, depth = 0) {
            if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) return;
            if (revealed[row][col] || flagged[row][col]) return;

            revealed[row][col] = true;
            revealQueue.push({ r: row, c: col, depth: depth });

            if (board[row][col] === -1) {
                hitMine = { r: row, c: col }; // Track which mine was hit
                playMine();
                screenShake();
                endGame(false);
                return;
            }

            if (board[row][col] === 0) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        reveal(row + dr, col + dc, depth + 1);
                    }
                }
            }
        }

        function checkWin() {
            let unrevealedSafe = 0;
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (!revealed[r][c] && board[r][c] !== -1) {
                        unrevealedSafe++;
                    }
                }
            }
            if (unrevealedSafe === 0) {
                endGame(true);
            }
        }

        function endGame(won) {
            gameOver = true;
            clearInterval(timerInterval);

            // Reveal all mines
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (board[r][c] === -1) revealed[r][c] = true;
                }
            }
            renderBoard();

            const elapsed = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0;
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

            let newBestText = '';
            if (won) {
                playWin();
                confetti(80);
                document.querySelector('.board-wrapper').classList.add('won');

                const currentBest = bestTimes[gridSize];
                if (currentBest === 0 || elapsed < currentBest) {
                    bestTimes[gridSize] = elapsed;
                    localStorage.setItem(`fraudFinderBest${gridSize}`, elapsed);
                    // Also save overall best for hub page
                    const overallBest = parseInt(localStorage.getItem('fraudFinderBest')) || 0;
                    if (overallBest === 0 || elapsed < overallBest) {
                        localStorage.setItem('fraudFinderBest', timeStr);
                    }
                    newBestText = '<br><span style="color: #ffd700; animation: pulse 0.5s ease-in-out infinite alternate;">NEW BEST TIME!</span>';
                    // Extra celebration for new best
                    setTimeout(() => confetti(50), 500);
                }
            }

            overlayTitle.textContent = won ? 'AUDIT COMPLETE!' : 'FRAUD DETECTED!';
            overlayTitle.className = 'overlay-title ' + (won ? 'win' : 'lose');
            overlayStats.innerHTML = `Time: ${timeStr}${newBestText}`;
            overlay.classList.add('active');
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            timeEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gridSize = parseInt(btn.dataset.size);
                mineCount = parseInt(btn.dataset.mines);
                createGame();
            });
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            overlay.classList.remove('active');
            createGame();
        });

        createGame();
    </script>
</body>
</html>
